
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>[每天五分钟，备战架构师-4]操作系统之设备管理 - Cocowool - 博客园</title>
<meta property="og:description" content="设备管理 设备管理是对计算机输入、输出系统的管理，这是操作系统最具有多样性和复杂性的部分，其主要任务是选择合适的设备进行数据传输，控制数据交换的过程，为用户提供透明的接口让用户不必关心设备的特性，为完" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/43046.css?v=jIe%2bqkoe6NGEDBHSKfZFtSP%2bk3Q%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/Custom/bundle-Custom-mobile.css?v=D4ZG96to-4HBTPc_nukUGx4UJPJRCpcXUrj8NiiyXiU1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/cocowool/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/cocowool/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/cocowool/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'cocowool', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=0t5BJebAFvrpW2OAhYKrwtj8nG5UE2GXuvUfBo9JUgs1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<div id="bgoverlay"></div>
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/cocowool/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/cocowool/">小狼的世界</a></h1>
<h2>不积跬步，无以至千里、不积细流，无以成江海</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/cocowool/">首页</a></li>
<li></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Cocowool">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/cocowool/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/cocowool/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 363&nbsp; </span>
<span id="stats_article_count">文章 - 4&nbsp; </span>
<span id="stats-comment_count">评论 - 449</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/cocowool/p/sa_device_management.html">[每天五分钟，备战架构师-4]操作系统之设备管理</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180704081910768-710549160.png" /></p>
<h3 id="设备管理">设备管理</h3>
<p>设备管理是对计算机输入、输出系统的管理，这是操作系统最具有多样性和复杂性的部分，其主要任务是选择合适的设备进行数据传输，控制数据交换的过程，为用户提供透明的接口让用户不必关心设备的特性，为完成这些任务，需要提供的功能主要包括：缓冲区管理、设备分配、设备处理、虚拟设备管理、实现设备独立性等。</p>
<h4 id="设备类型">设备类型</h4>
<p>系统设备的分类方法有很多种，比如说按有没有线分为有线设备、无线设备，具体的看思维导图吧。</p>
<p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180704081921074-860541647.png" /></p>
<h4 id="设备连接">设备连接</h4>
<p>现代计算机系统对外部设备的控制通常分为：通道、控制器和设备。</p>
<p>__设备控制器__是计算机中的一个实体，其主要职责是控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，它接收从CPU发来的命令，并去控制I/O设备工作，以使处理从繁杂的设备控制事务中解脱出来。</p>
<p>__通道__的主要目的是为了建立独立的I/O操作，不仅使数据的传送能独立于CPU，而且也希望有关对I/O操作的组织、管理及其结束处理尽量独立，以保证CPU有更多的时间去进行数据处理。</p>
<p>控制设备的软件分为与设备有关的，例如驱动程序，和与设备无关的，如控制器的公共部分。</p>
<h4 id="数据传输控制">数据传输控制</h4>
<p>外围设备和内存之间常用的数据传送控制方式主要有以下几种方式：</p>
<p><strong>程序控制方式</strong></p>
<p>在早期计算机系统中，由于无中断机构，处理机对I/O设备的控制采取程序I/O方式，或称为忙-等待方式，即在处理机向控制器发出一条I/O指令启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy设置为1，然后便不断地循环测试busy，只有当其为0时，表示输入已经送入控制器的数据寄存器中，于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字（符）的I/O。</p>
<p>在程序I/O方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成对CPU的极大浪费。</p>
<p><strong>中断控制方式</strong></p>
<p>当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务，设备控制器于是按照该命令的要求去控制指定I/O设备，此时，CPU与I/O设备并行操作。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一个中断信号，由CPU检查输入过程中是否出错，若无错，便由控制器发送取走数据的信号，再通过控制器及数据线将数据写入内存指定单元中。</p>
<p>在I/O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I/O设备并行工作，仅当完成一个数据输入时，才需CPU花费极短的时间去做一些中断处理。</p>
<p><strong>直接存储访问方式DMA</strong></p>
<p>虽然中断驱动I/O比程序I/O方式更有效，但是，它仍是以字（节）为单位进行I/O的，每当完成一个字（节）的I/O时，控制器便要向CPU请求一次中断，换言之，采用中断驱动I/O方式时的CPU是以字（节）为单位进行干预的，将这种方式用于块设备的I/O是非常低效的。</p>
<p>DMA方式指外部设备和内存之间开辟直接的数据交换通路。DMA控制器由三部分组成，主机与DMA控制器的接口；DMA控制器与块设备的接口；I/O控制逻辑。</p>
<p><strong>通道控制方式</strong></p>
<p>I/O通道方式是DMA的发展，它可以进一步减少CPU的干预，即把一个数据块的读（或写）为单位的干预减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，可以实现CPU、通道、I/O设备的并行操作，提高资源利用率。</p>
<p>通道是通过执行通道程序，并与设备控制器共同实现对I/O设备的控制的，通道程序是由一系列通道指令（或称为通道命令）所构成的。</p>
<h4 id="设备分配">设备分配</h4>
<p>多道程序系统中，设备不允许用户直接使用，而是由操作系统统一调度和控制。设备分配功能是设备管理的基本任务。设备分配程序按照一定的策略，为申请设备的用户程序分配设备，记录设备的使用情况。</p>
<h4 id="磁盘调度">磁盘调度</h4>
<p>磁盘设备包括一个或多个物理盘片，每个盘片分一个或两个存储面，每个磁盘面被组织成若干个同心环，这种环称为磁道，各磁道之间留有必要的缝隙。每条磁道上可存储相同数目的二进制位，这样，磁盘密度即每英寸中所存储的位数，显然是内层磁道密度较外层磁道的密度高，每条磁道又被逻辑上划分成若干个扇区，一个扇区称为一个盘块（数据块）或称为磁盘扇区。一个物理记录存储在一个扇区上，磁盘上存储的物理记录块数目是由扇区数、磁道数以及盘面数决定的。</p>
<p>磁盘是多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳的调度算法，使各进程对磁盘的平均访问时间最小。由于在访问磁盘中，主要是寻道时间，因此，磁盘调度的目标是使磁盘的平均寻道时间最少。目前常用的磁盘调度算法有先来先服务、最短寻道时间优先及扫描等算法。</p>
<p><strong>先来先服务（FCFS, First Come First Service）</strong></p>
<p>这是一种最简单的磁盘调度算法，其根据进程请求访问磁盘的先后顺序进行调度，优点是公平、简单，每个进程的请求都能得到依次处理，不会出现某个进程的请求长期得不到满足的情况。</p>
<p><strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong></p>
<p>要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。</p>
<p><strong>扫描（SCAN）算法</strong></p>
<p>SSTF算法虽然能获得较好的寻道性能，但可能会导致某个进程发生饥饿现象，因为只要有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I/O请求必然先满足，对SSTF算法修改后形成SCAN算法，可防止老进程出现饥饿现象。该算法不仅考虑到欲访问的磁盘与当前磁道之间的距离，更优先考虑的是磁头当前的移动方向。例如，当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。其类似电梯的运行，也称为电梯调度算法。</p>
<p><strong>循环扫描（CSCAN）算法</strong></p>
<p>SCAN算法既能够获得较好的寻道性能，又能防止饥饿现象，但是，当磁头刚从里向外移动而越过了某个磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。为了减少这种延迟，CSCAN算法规定磁头单向移动，例如，致使自里向外移动，当磁头移到最外的磁道访问后，磁头立即返回最里的欲访问的磁道，即将最小的磁道号紧接着最大的磁道号构成循环，进行循环扫描。</p>
<p><strong>NStepSCAN算法</strong></p>
<p>在SSTF、SCAN、CSCAN几种调度算法中，都可能会出现磁臂停留在某处不动的情况，例如，有一个或几个进程对某个磁道具有较高的访问频率，即这些进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备，这一现象称为磁臂粘着。NStepSCAN算法将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法一次处理这些子队列，当正在处理某子队列时，如果又出现了新的磁盘请求，便将新的请求进程放入其他队列，这样就避免了出现粘着现象。当N很大时，会使N步扫描算法性能接近于SCAN算法，当N=1时，退化为FCFS算法。</p>
<p><strong>FSCAN算法</strong></p>
<p>其是NStepSCAN的简化，即FSCAN只将磁盘请求队列分成两个子队列，一个是由当前所有请求磁盘I/O的进程所形成的队列，由磁盘调度按SCAN算法进行处理，在扫描期间，将新出现的请求磁盘I/O的进程放入另一个等待处理的请求队列。这样，所有的新请求都被推迟到下一次扫描时处理。</p>
<h4 id="spooling-技术">SPOOLING 技术</h4>
<p>SPOOLING(Simultaneous Peripheral Operation On Line)是低速输入输出设备与主机交换的一种技术，通常也称为“假脱机真联机”。利用SPOOLING技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。SPOOLING系统必须有高速、大容量并且可随机存取的外存。</p>
<p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180704081946870-18790756.png" /></p>
<p>参考资料：<br />
1、<a href="https://www.cnblogs.com/tangshiguang/p/6746245.html">【操作系统】设备管理（五）</a><br />
2、<a href="https://baike.baidu.com/item/SPOOLing技术/9240532">SPOOLing技术</a><br />
3、<a href="https://blog.csdn.net/daiyibo123/article/details/46398795">操作系统--设备管理</a></p>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2018-07-04 08:20</span> <a href='https://www.cnblogs.com/cocowool/'>Cocowool</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=9261523" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9261523);return false;">收藏</a></div>
	</div>
	<script src="//common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script type="text/javascript">var allowComments=true,cb_blogId=43046,cb_entryId=9261523,cb_blogApp=currentBlogApp,cb_blogUserGuid='6151420b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2018/7/4 8:20:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>

<script>
  googletag.cmd.push(function() {
    googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.enableServices();
  });
</script>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'>
    <script>
    if (new Date() >= new Date(2018, 9, 13)) {
        googletag.cmd.push(function() { googletag.display('div-gpt-ad-1539008685004-0'); });
    }
    </script>
    </div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2018 Cocowool
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?433c388afd6e0af1d67cfe808874c659";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!--PageEndHtml Block End-->
</body>
</html>
