
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>Python3.6学习笔记（二） - Cocowool - 博客园</title>
<meta property="og:description" content="Python 的高级特性 切片 对于指定索引范围取值的操作，Python提供了 方法，类似于Excel中数据透视表的切片器。 tuple也是一种list，唯一区别是tuple不可变。因此，tuple也" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/43046.css?v=jIe%2bqkoe6NGEDBHSKfZFtSP%2bk3Q%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/Custom/bundle-Custom-mobile.css?v=D4ZG96to-4HBTPc_nukUGx4UJPJRCpcXUrj8NiiyXiU1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/cocowool/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/cocowool/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/cocowool/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'cocowool', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=0t5BJebAFvrpW2OAhYKrwtj8nG5UE2GXuvUfBo9JUgs1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<div id="bgoverlay"></div>
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/cocowool/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/cocowool/">小狼的世界</a></h1>
<h2>不积跬步，无以至千里、不积细流，无以成江海</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/cocowool/">首页</a></li>
<li></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Cocowool">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/cocowool/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/cocowool/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 363&nbsp; </span>
<span id="stats_article_count">文章 - 4&nbsp; </span>
<span id="stats-comment_count">评论 - 449</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/cocowool/p/6626958.html">Python3.6学习笔记（二）</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><h2 id="python-的高级特性">Python 的高级特性</h2>
<h3 id="切片">切片</h3>
<p>对于指定索引范围取值的操作，Python提供了<code>slice</code>方法，类似于Excel中数据透视表的切片器。</p>
<pre class="python"><code>&gt;&gt;&gt; L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack’]    #声明一个List，取前三个值
&gt;&gt;&gt; L[0:3]    #表示从0开始，到3为止，但是不包括3，后面还可以再接:加上步长
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy’]
&gt;&gt;&gt; S=list(range(100))    #声明一个0-99的list
&gt;&gt;&gt; S[0:100:9]            #取9的倍数
[0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]</code></pre>
<blockquote>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</p>
</blockquote>
<h3 id="迭代-iteration">迭代 Iteration</h3>
<p>给定一个list或tulp，可以通过<code>for</code>循环来遍历，这称之为<em>迭代</em>。Python中的迭代类似于Javascript，而与PHP或Java采用下标迭代的方式不同。对于Python来说，dict、set、字符串等都是可迭代对象，都可以使用for循环。<em>只要作用于一个可迭代对象，for循环就可以正常运行</em>，而我们不太关心该对象究竟是list还是其他数据类型。</p>
<p>判断一个对象是否可迭代，通过collections模块的Iterable类型判断。</p>
<pre class="python"><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False</code></pre>
<blockquote>
<p>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。</p>
</blockquote>
<h3 id="列表生成式">列表生成式</h3>
<p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。写列表生成式时，把要生成的元素放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<pre class="python"><code>tiangan = &#39;甲乙丙丁戊己庚辛壬癸&#39;
dizhi = &#39;子丑寅卯辰巳午未申酉戌亥&#39;

jiazi = [tiangan[x % len(tiangan)] + dizhi[x % len(dizhi)] for x in range(60)]</code></pre>
<p>for循环后面还可以加上if判断。</p>
<pre class="python"><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]</code></pre>
<p>还可以使用两层循环，可以生成全排列。</p>
<pre class="python"><code>&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, ‘CZ&#39;]</code></pre>
<h3 id="生成器">生成器</h3>
<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>生成generator有两个办法。</p>
<p>1、只要把一个列表生成式的[]改成()，就创建了一个generator。</p>
<pre class="python"><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</code></pre>
<p>generator保存的是算法，每次调用<code>next(g)</code>，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。通常，可以使用<code>for</code>循环来遍历生成器中的内容。</p>
<p>2、如果算法比较复杂，可以使用函数来实现。</p>
<pre class="python"><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;</code></pre>
<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>
<h3 id="迭代器">迭代器</h3>
<p>这里主要区分 <code>Iterable</code> 和 <code>Iterator</code> 。</p>
<p>对于 <code>Iterable</code> 的数据类型，称之为可迭代对象，可以使用for循环遍历，包括<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>、生成器以及带<code>yield</code>的Generator Function。可以使用 <code>isinstance()</code> 函数判断是否为 Iterable 。</p>
<p>迭代器不仅可以使用<code>for</code>循环，还可以使用<code>next()</code>函数不断调用返回下一个值，直到最后抛出<em>StopIteration</em>错误表示无法继续返回下一个值了。这样，就可以把数据流看作一个有序序列，我们不知道序列的长度，但是可以通过不断的计算获取下一个值。</p>
<blockquote>
<p>可以使用 <code>iter()</code> 函数把 <code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>。</p>
</blockquote>
<h2 id="函数式编程">函数式编程</h2>
<p>我之前熟悉的PHP、C，编写程序多是通过将任务分解为一个个Function，然后组合起来解决问题的，这种分解称为面向过程的程序设计，而函数是面向过程的程序设计的基本单元。</p>
<p>函数式编程（Functional Programming）其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>Python对函数式编程提供部分支持。</p>
<h3 id="高阶函数-high-order-function">高阶函数 High order function</h3>
<h4 id="变量可以指向函数">变量可以指向函数</h4>
<p>这个对我真是有点颠覆，看下面的例子。</p>
<pre class="python"><code>&gt;&gt; abs(-10)
10
&gt;&gt;&gt; abs
&lt;built-in function abs&gt;
&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10</code></pre>
<h3 id="函数名也是变量">函数名也是变量</h3>
<p>Python中函数名其实就是指向函数的变量。</p>
<pre class="python"><code>&gt;&gt;&gt; abs=10
&gt;&gt;&gt; abs
10
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;int&#39; object is not callable
&gt;&gt;&gt; f(-10)
10</code></pre>
<h3 id="传入函数">传入函数</h3>
<p>函数的参数如果接收一个指向函数的变量，就变成了一个函数接收另一个函数作为参数，这种函数称为高阶函数。函数式编程就是指这种高度抽象的编程范式</p>
<h3 id="map-reduce">map / reduce</h3>
<p>Python内建了<code>map()</code>和<code>reduce()</code>函数。<code>map()</code>函数接收两个参数，一个是<em>函数</em>，一个是<em>Iterable</em>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<pre class="python"><code>&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>
<p><code>reduce</code>把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code>。</p>
<h3 id="filter">filter</h3>
<p>Python内建的函数<code>filter()</code>用于过滤序列，其接收一个函数和一个序列，并把传入的函数作用于每个元素，然后根据返回值是True还是False决定是保留还是丢弃该元素。</p>
<pre class="python"><code>def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</code></pre>
<blockquote>
<p>注意到filter()函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p>
</blockquote>
<h3 id="sorted-排序算法">sorted 排序算法</h3>
<p>排序是程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。Python内置的<code>sorted()</code>函数就可以对list进行排序。<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>。</p>
<pre class="python"><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]</code></pre>
<h3 id="函数作为返回值">函数作为返回值</h3>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。如下示例，调用<code>lazy_sum</code>时，返回的并不是求和结果，而是求和函数。这种结构称为<em>闭包 Closure</em>。</p>
<pre class="python"><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum</code></pre>
<blockquote>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</blockquote>
<h3 id="匿名函数">匿名函数</h3>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数。关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>
<pre class="python"><code>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>
<blockquote>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p>
</blockquote>
<h3 id="装饰器">装饰器</h3>
<p>函数对象有一个__name__属性，可以拿到函数的名字。现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为<em>“装饰器”（Decorator）</em>。</p>
<pre class="python"><code>def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper</code></pre>
<p>借助Python的@语法，把decorator置于函数的定义处。</p>
<pre class="python"><code>@log
def now():
    print(&#39;2015-3-25&#39;)

&gt;&gt;&gt; now()
call now():    #调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志
2015-3-25</code></pre>
<blockquote>
<p>把@log放到now()函数的定义处，相当于执行了语句:<code>now = log(now)</code></p>
</blockquote>
<p>对于上面这种写法，如果调用<code>__name__</code>方法，返回的函数名为 wrapper ，需要用Python内置的 functools.wraps 来解决。</p>
<pre class="python"><code>import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper</code></pre>
<pre class="python"><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator</code></pre>
<h3 id="偏函数">偏函数</h3>
<p>Python 的 functools 提供了很多有用的功能，其中一个就是<em>偏函数（Partial function）</em>。</p>
<pre class="python"><code>def int2(x, base=2):
    return int(x, base)

&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
&gt;&gt;&gt; int2(&#39;1010101&#39;)
85</code></pre>
<p>如上例子，通过使用偏函数，我们相当于对函数做了一个包装，默认输入了一些函数参数，减少了后续调用时输入的参数个数。实现这个功能，可以借助 functools。</p>
<pre class="python"><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
&gt;&gt;&gt; int2(&#39;1010101&#39;)
85
&gt;&gt;&gt; int2(&#39;1000000&#39;, base=10)
1000000</code></pre>
<h2 id="模块">模块</h2>
<p>任何语言要实现一个项目，都离不开文件组织管理。在Python中，一个.py文件就称之为一个模块（Module）。使用模块可以提高代码的可维护性，也可以避免函数名和变量名冲突。但是也要注意，尽量不要与内置函数名字冲突。为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p>
<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块。类似的，可以有多级目录，组成多级层次的包结构。</p>
<blockquote>
<p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p>
</blockquote>
<h3 id="使用模块">使用模块</h3>
<p>看一段代码，引用了<code>sys</code>模块，定义了hello模块。</p>
<pre class="python"><code>#!/usr/bin/env python3    #标准注释
# -*- coding: utf-8 -*-   #表示.py文件本身使用标准UTF-8编码

&#39; a test module &#39;

__author__ = &#39;Michael Liao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print(&#39;Hello, world!&#39;)
    elif len(args)==2:
        print(&#39;Hello, %s!&#39; % args[1])
    else:
        print(&#39;Too many arguments!&#39;)

if __name__==&#39;__main__&#39;:
    test()</code></pre>
<p>导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p>
<h3 id="作用域">作用域</h3>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用。之所以我们说，private函数和变量<em>“不应该”</em>被直接引用，而不是<em>“不能”</em>被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<h3 id="安装第三方模块">安装第三方模块</h3>
<p>在Python中，安装第三方模块，是通过包管理工具pip完成的。在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。</p>
<blockquote>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是<code>pip3</code>。</p>
</blockquote>
<p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是</p>
<pre class="python"><code>pip install Pillow</code></pre>
<p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180710163655709-89635310.png" alt="欢迎关注我的微信公众号" /></p>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2017-03-27 15:27</span> <a href='https://www.cnblogs.com/cocowool/'>Cocowool</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=6626958" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6626958);return false;">收藏</a></div>
	</div>
	<script src="//common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script type="text/javascript">var allowComments=true,cb_blogId=43046,cb_entryId=6626958,cb_blogApp=currentBlogApp,cb_blogUserGuid='6151420b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2017/3/27 15:27:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>

<script>
  googletag.cmd.push(function() {
    googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.enableServices();
  });
</script>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'>
    <script>
    if (new Date() >= new Date(2018, 9, 13)) {
        googletag.cmd.push(function() { googletag.display('div-gpt-ad-1539008685004-0'); });
    }
    </script>
    </div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2018 Cocowool
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?433c388afd6e0af1d67cfe808874c659";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!--PageEndHtml Block End-->
</body>
</html>
