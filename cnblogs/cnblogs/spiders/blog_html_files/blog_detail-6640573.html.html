
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>Python3.6学习笔记（三） - Cocowool - 博客园</title>
<meta property="og:description" content="面向对象编程 面向对象编程 Object Oriented Programming 简称 OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/43046.css?v=jIe%2bqkoe6NGEDBHSKfZFtSP%2bk3Q%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/Custom/bundle-Custom-mobile.css?v=D4ZG96to-4HBTPc_nukUGx4UJPJRCpcXUrj8NiiyXiU1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/cocowool/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/cocowool/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/cocowool/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'cocowool', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=0t5BJebAFvrpW2OAhYKrwtj8nG5UE2GXuvUfBo9JUgs1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<div id="bgoverlay"></div>
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/cocowool/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/cocowool/">小狼的世界</a></h1>
<h2>不积跬步，无以至千里、不积细流，无以成江海</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/cocowool/">首页</a></li>
<li></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Cocowool">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/cocowool/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/cocowool/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 363&nbsp; </span>
<span id="stats_article_count">文章 - 4&nbsp; </span>
<span id="stats-comment_count">评论 - 449</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/cocowool/p/6640573.html">Python3.6学习笔记（三）</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><h2 id="面向对象编程">面向对象编程</h2>
<p>面向对象编程 Object Oriented Programming 简称 OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<blockquote>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
</blockquote>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<pre class="python"><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))</code></pre>
<h3 id="类和实例">类和实例</h3>
<p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p>
<p>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的。<code>__init__</code>函数与其它函数有所不同，它的第一个参数永远是实例变量self，并且，调用时，不用传递该参数。</p>
<h3 id="数据封装">数据封装</h3>
<p>类本身拥有数据和方法，相当于将“数据”封装起来了。对于外部来说，并不需要知道内部的逻辑。</p>
<h3 id="访问限制">访问限制</h3>
<p>Class可以有属性和方法，我们可以对属性和方法进行控制，以达到允许或者不允许外部访问的目的。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<pre class="python"><code>class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.__name, self.__score))

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError(&#39;bad score’)</code></pre>
<blockquote>
<p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
</blockquote>
<h3 id="继承和多态">继承和多态</h3>
<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<pre class="python"><code>class Animal(object):
    def run(self):
        print(&#39;Animal is running…&#39;)

class Dog(Animal):

    def run(self):
        print(&#39;Dog is running...&#39;)

class Cat(Animal):

    def run(self):
        print(&#39;Cat is running…&#39;)</code></pre>
<p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：<em>多态</em>。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p><em>对扩展开放</em>：允许新增Animal子类；</p>
<p><em>对修改封闭</em>：不需要修改依赖Animal类型的外部函数。</p>
<h3 id="鸭子类型">鸭子类型</h3>
<p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用run()方法。对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<h3 id="获取对象信息">获取对象信息</h3>
<p>判断Python中对象的类型，可以用以下方法。</p>
<h4 id="type">type()</h4>
<p>基本类型都可以用<code>type()</code>判断，基本数据类型可以直接写<code>int</code>、<code>str</code>，判断是否函数需要使用types中定义的常量。</p>
<pre class="python"><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; def fn():
...     pass
...
&gt;&gt;&gt; type(fn)==types.FunctionType
True
&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType
True</code></pre>
<h4 id="isinstance">isinstance()</h4>
<p>对于类和实例，使用<code>type()</code>就不是很方便，可以使用<code>isinstance()</code>。基本数据类型也可以使用<code>isinstance()</code>判断。还可以判断一个变量是否是某些类型中的一种。</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))
True
&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))
True</code></pre>
<h4 id="dir">dir()</h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法。</p>
<h3 id="实例属性和类属性">实例属性和类属性</h3>
<p>Python类创建的实例可以任意绑定属性，如果需要对类本身绑定属性，则需要在类中定义，这就区分了类属性和实例属性。</p>
<blockquote>
<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
</blockquote>
<h2 id="面向对象高级编程">面向对象高级编程</h2>
<p>数据封装、继承和多态是面相对象程序设计中的三个基本概念，另外还有很多特性，包括多重继承、定制类等。</p>
<h3 id="使用-slots">使用 <strong>slots()</strong></h3>
<p>在Python中，可以对类动态的增加属性和方法，这在静态语言中很难实现。</p>
<pre class="python"><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

class Student(object):
     def __init__(self):
          print(&quot;Instance Created&quot;)


Tracy = Student()
Tracy.age = 30
Bob = Student()
Bob.age = 41
Ceaser = Student()

print(Tracy.age)
print(Bob.age)

def set_age(self, age):
     self.age = age

from types import MethodType
s = Student()
s.set_age = MethodType(set_age, s)
s.set_age(25)
print(s.age)

Student.set_age = set_age
Ceaser.set_age(33)
print(Ceaser.age)</code></pre>
<p>但这也带来一个问题，属性和方法可以随意更改，如果我们要限制怎么办？可以使用<code>__slots</code>。Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性。使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p>
<pre class="python"><code>class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称</code></pre>
<h3 id="使用property">使用@Property</h3>
<p>Python中实例的属性暴露在外面可以随便修改，这样就无法保证属性的有效性符合校验规则。虽然可以通过设置Setter和Getter来进行检查，但如果属性特别多，操作起来又比较麻烦。</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的。</p>
<pre class="python"><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value</code></pre>
<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。</p>
<pre class="python"><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!</code></pre>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。</p>
<pre class="python"><code>class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth</code></pre>
<h3 id="多重继承">多重继承</h3>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。举例来说对于动物的对象设计，可以按照“哺乳动物”、“鸟类”来设计分类对象，按照不同的维度，也可以按照“能跑的”、“能飞的”或者“宠物”、“非宠物”设计分类，如果按照单一继承的方式，类的设计就像下图，会变的非常复杂。</p>
<p><img src="https://images2015.cnblogs.com/blog/39469/201703/39469-20170329165107889-1802684434.png" /></p>
<p>正确的办法是采用多重继承。一个子类就可以同时获得多个父类的所有功能。在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为<em>MixIn</em>。</p>
<pre class="python"><code>class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass

class Runnable(object):
    def run(self):
        print(&#39;Running...&#39;)

class Flyable(object):
    def fly(self):
        print(&#39;Flying…’)

class Dog(Mammal, Runnable):
    pass

class Bat(Mammal, Flyable):
    pass</code></pre>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。</p>
<h3 id="定制类">定制类</h3>
<p>类似于<code>__slots__</code>，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h4 id="str"><strong>str</strong></h4>
<p>定义<code>print</code> 函数调用时的返回结果。</p>
<pre class="python"><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
...
&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
Student object (name: Michael)</code></pre>
<h4 id="repr"><strong>repr</strong></h4>
<p>定义返回程序开发者看到的字符串，也就是在命令行状态下执行时的返回值。</p>
<pre class="python"><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__</code></pre>
<h4 id="iter"><strong>iter</strong></h4>
<p>如果一个类想被用于<code>for … in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p>
<pre class="python"><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值</code></pre>
<h4 id="getitem"><strong>getitem</strong></h4>
<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素。</p>
<pre class="python"><code>class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L</code></pre>
<p>通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h4 id="getattr"><strong>getattr</strong></h4>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。</p>
<pre class="python"><code>class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99

</code></pre>
<h4 id="call"><strong>call</strong></h4>
<p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。<code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<pre class="python"><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)</code></pre>
<h3 id="使用枚举类">使用枚举类</h3>
<p>之前说到过，Python中其实不存在常量，但是可以通过枚举类的方式来变通实现。</p>
<pre class="python"><code>from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)

from enum import Enum, unique

@unique            #@unique装饰器可以帮助我们检查保证没有重复值。
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6</code></pre>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员。</p>
<h3 id="使用元类">使用元类</h3>
<h4 id="type-1">type()</h4>
<p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。</p>
<p>type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义。</p>
<pre class="python"><code>&gt;&gt;&gt; def fn(self, name=&#39;world&#39;): # 先定义函数
...     print(&#39;Hello, %s.&#39; % name)
...
&gt;&gt;&gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;__main__.Hello’&gt;</code></pre>
<p>要创建一个class对象，type()函数依次传入3个参数：</p>
<p>1.class的名称；<br />
2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；<br />
3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</p>
<p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。</p>
<h4 id="metaclass">metaclass</h4>
<p>metaclass，直译为元类，简单的解释就是：<br />
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br />
但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p>
<pre class="python"><code># metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attires)</code></pre>
<p><img src="https://images2018.cnblogs.com/blog/39469/201807/39469-20180710163655709-89635310.png" alt="欢迎关注我的微信公众号" /></p>
<p>参考资料：<br />
1、<a href="http://docs.python.org/3/reference/datamodel.html#special-method-names">Python 3 官方文档</a></p>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2017-03-29 16:51</span> <a href='https://www.cnblogs.com/cocowool/'>Cocowool</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=6640573" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6640573);return false;">收藏</a></div>
	</div>
	<script src="//common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script><script>markdown_highlight();</script><script type="text/javascript">var allowComments=true,cb_blogId=43046,cb_entryId=6640573,cb_blogApp=currentBlogApp,cb_blogUserGuid='6151420b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2017/3/29 16:51:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>

<script>
  googletag.cmd.push(function() {
    googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.enableServices();
  });
</script>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'>
    <script>
    if (new Date() >= new Date(2018, 9, 13)) {
        googletag.cmd.push(function() { googletag.display('div-gpt-ad-1539008685004-0'); });
    }
    </script>
    </div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2018 Cocowool
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?433c388afd6e0af1d67cfe808874c659";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!--PageEndHtml Block End-->
</body>
</html>
